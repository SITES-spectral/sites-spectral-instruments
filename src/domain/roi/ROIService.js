/**
 * ROI Domain Service
 *
 * Business logic for ROI (Region of Interest) operations.
 * Orchestrates domain entities and repository operations.
 *
 * @module domain/roi/ROIService
 * @version 11.0.0
 */

import { ROI } from './ROI.js';

/**
 * ROI Service - Business logic for ROI operations
 */
export class ROIService {
  /**
   * @param {import('./ROIRepository.js').ROIRepository} roiRepository
   */
  constructor(roiRepository) {
    this.roiRepository = roiRepository;
  }

  /**
   * Get ROI by ID
   * @param {number} id
   * @returns {Promise<ROI|null>}
   */
  async getById(id) {
    return this.roiRepository.findById(id);
  }

  /**
   * Get ROIs for an instrument
   * @param {number} instrumentId
   * @param {Object} [options]
   * @param {boolean} [options.includeLegacy=false]
   * @returns {Promise<ROI[]>}
   */
  async getByInstrument(instrumentId, options = {}) {
    return this.roiRepository.findByInstrumentId(instrumentId, options);
  }

  /**
   * Get ROIs for a station
   * @param {number} stationId
   * @param {Object} [options]
   * @param {boolean} [options.includeLegacy=false]
   * @returns {Promise<ROI[]>}
   */
  async getByStation(stationId, options = {}) {
    return this.roiRepository.findByStationId(stationId, options);
  }

  /**
   * Get all ROIs with filtering and pagination
   * @param {Object} filters
   * @param {Object} pagination
   * @returns {Promise<{rois: ROI[], total: number, page: number, limit: number}>}
   */
  async getAll(filters = {}, pagination = {}) {
    return this.roiRepository.findAll(filters, pagination);
  }

  /**
   * Create a new ROI
   * @param {Object} data - ROI data
   * @returns {Promise<{success: boolean, roi?: ROI, errors?: string[]}>}
   */
  async create(data) {
    // Generate ROI name if not provided
    let roiName = data.roiName || data.roi_name;
    if (!roiName) {
      roiName = await this.roiRepository.getNextROIName(data.instrumentId || data.instrument_id);
    }

    // Create ROI entity
    const roi = new ROI({
      instrumentId: data.instrumentId || data.instrument_id,
      roiName,
      displayName: data.displayName || data.display_name,
      description: data.description,
      pointsJson: data.pointsJson || data.points_json,
      colorR: data.colorR ?? data.color_r ?? 255,
      colorG: data.colorG ?? data.color_g ?? 0,
      colorB: data.colorB ?? data.color_b ?? 0,
      alpha: data.alpha ?? 0.3,
      thickness: data.thickness ?? 7,
      autoGenerated: data.autoGenerated ?? data.auto_generated ?? false,
      generatedDate: data.generatedDate || data.generated_date,
      sourceImage: data.sourceImage || data.source_image,
      vegetationType: data.vegetationType || data.vegetation_type,
      status: data.status || ROI.STATUSES.ACTIVE
    });

    // Validate
    const validation = roi.validate();
    if (!validation.valid) {
      return { success: false, errors: validation.errors };
    }

    // Check for duplicate name
    const exists = await this.roiRepository.existsByName(roi.instrumentId, roi.roiName);
    if (exists) {
      return { success: false, errors: [`ROI name '${roi.roiName}' already exists for this instrument`] };
    }

    // Save
    const savedRoi = await this.roiRepository.save(roi);
    return { success: true, roi: savedRoi };
  }

  /**
   * Update an existing ROI
   * @param {number} id - ROI ID
   * @param {Object} data - Fields to update
   * @returns {Promise<{success: boolean, roi?: ROI, errors?: string[]}>}
   */
  async update(id, data) {
    const existing = await this.roiRepository.findById(id);
    if (!existing) {
      return { success: false, errors: ['ROI not found'] };
    }

    // Check if can be edited (not legacy)
    if (!existing.canBeEdited()) {
      return { success: false, errors: ['This ROI cannot be edited (legacy or archived)'] };
    }

    // Update fields
    if (data.displayName !== undefined || data.display_name !== undefined) {
      existing.displayName = data.displayName || data.display_name;
    }
    if (data.description !== undefined) {
      existing.description = data.description;
    }
    if (data.pointsJson !== undefined || data.points_json !== undefined) {
      existing.pointsJson = data.pointsJson || data.points_json;
    }
    if (data.colorR !== undefined || data.color_r !== undefined) {
      existing.colorR = data.colorR ?? data.color_r;
    }
    if (data.colorG !== undefined || data.color_g !== undefined) {
      existing.colorG = data.colorG ?? data.color_g;
    }
    if (data.colorB !== undefined || data.color_b !== undefined) {
      existing.colorB = data.colorB ?? data.color_b;
    }
    if (data.alpha !== undefined) {
      existing.alpha = data.alpha;
    }
    if (data.thickness !== undefined) {
      existing.thickness = data.thickness;
    }
    if (data.sourceImage !== undefined || data.source_image !== undefined) {
      existing.sourceImage = data.sourceImage || data.source_image;
    }
    if (data.vegetationType !== undefined || data.vegetation_type !== undefined) {
      existing.vegetationType = data.vegetationType || data.vegetation_type;
    }
    if (data.status !== undefined) {
      existing.status = data.status;
    }

    // Validate
    const validation = existing.validate();
    if (!validation.valid) {
      return { success: false, errors: validation.errors };
    }

    // Save
    const savedRoi = await this.roiRepository.save(existing);
    return { success: true, roi: savedRoi };
  }

  /**
   * Admin override update - directly edit ROI and set timeseries_broken flag
   * @param {number} id - ROI ID
   * @param {Object} data - Fields to update
   * @returns {Promise<{success: boolean, roi?: ROI, timeseriesBroken?: boolean, errors?: string[]}>}
   */
  async adminOverrideUpdate(id, data) {
    const existing = await this.roiRepository.findById(id);
    if (!existing) {
      return { success: false, errors: ['ROI not found'] };
    }

    // Update fields (same as regular update)
    if (data.displayName !== undefined || data.display_name !== undefined) {
      existing.displayName = data.displayName || data.display_name;
    }
    if (data.description !== undefined) {
      existing.description = data.description;
    }
    if (data.pointsJson !== undefined || data.points_json !== undefined) {
      existing.pointsJson = data.pointsJson || data.points_json;
    }
    if (data.colorR !== undefined || data.color_r !== undefined) {
      existing.colorR = data.colorR ?? data.color_r;
    }
    if (data.colorG !== undefined || data.color_g !== undefined) {
      existing.colorG = data.colorG ?? data.color_g;
    }
    if (data.colorB !== undefined || data.color_b !== undefined) {
      existing.colorB = data.colorB ?? data.color_b;
    }
    if (data.alpha !== undefined) {
      existing.alpha = data.alpha;
    }
    if (data.thickness !== undefined) {
      existing.thickness = data.thickness;
    }
    if (data.sourceImage !== undefined || data.source_image !== undefined) {
      existing.sourceImage = data.sourceImage || data.source_image;
    }

    // Mark timeseries as broken if ROI is active (not legacy)
    let timeseriesBroken = false;
    if (!existing.isLegacy) {
      existing.markTimeseriesBroken();
      timeseriesBroken = true;
    }

    // Validate
    const validation = existing.validate();
    if (!validation.valid) {
      return { success: false, errors: validation.errors };
    }

    // Save
    const savedRoi = await this.roiRepository.save(existing);
    return { success: true, roi: savedRoi, timeseriesBroken };
  }

  /**
   * Delete a ROI
   * @param {number} id
   * @returns {Promise<{success: boolean, error?: string}>}
   */
  async delete(id) {
    const existing = await this.roiRepository.findById(id);
    if (!existing) {
      return { success: false, error: 'ROI not found' };
    }

    const deleted = await this.roiRepository.delete(id);
    return { success: deleted };
  }

  /**
   * Mark ROI as legacy and optionally create a replacement
   * @param {number} id - ROI ID to mark as legacy
   * @param {string} reason - Reason for marking as legacy
   * @param {Object} [replacementData] - Data for creating replacement ROI
   * @returns {Promise<{success: boolean, legacyRoi?: ROI, newRoi?: ROI, errors?: string[]}>}
   */
  async markAsLegacy(id, reason, replacementData = null) {
    const existing = await this.roiRepository.findById(id);
    if (!existing) {
      return { success: false, errors: ['ROI not found'] };
    }

    if (existing.isLegacy) {
      return { success: false, errors: ['ROI is already marked as legacy'] };
    }

    // Mark as legacy
    existing.markAsLegacy(reason);

    let newRoi = null;
    if (replacementData) {
      // Create replacement ROI
      const createResult = await this.create({
        instrumentId: existing.instrumentId,
        description: replacementData.description || existing.description,
        pointsJson: replacementData.pointsJson || replacementData.points_json || existing.pointsJson,
        colorR: replacementData.colorR ?? replacementData.color_r ?? existing.colorR,
        colorG: replacementData.colorG ?? replacementData.color_g ?? existing.colorG,
        colorB: replacementData.colorB ?? replacementData.color_b ?? existing.colorB,
        alpha: replacementData.alpha ?? existing.alpha,
        thickness: replacementData.thickness ?? existing.thickness,
        sourceImage: replacementData.sourceImage || replacementData.source_image || existing.sourceImage,
        vegetationType: replacementData.vegetationType || replacementData.vegetation_type || existing.vegetationType
      });

      if (createResult.success) {
        newRoi = createResult.roi;
        existing.replacedByROIId = newRoi.id;
      }
    }

    // Save the legacy ROI
    const legacyRoi = await this.roiRepository.save(existing);

    return {
      success: true,
      legacyRoi,
      newRoi
    };
  }

  /**
   * Get ROI with its replacement chain
   * @param {number} id
   * @returns {Promise<{current: ROI, legacy: ROI[], replacement: ROI|null}|null>}
   */
  async getWithReplacementChain(id) {
    return this.roiRepository.findWithReplacementChain(id);
  }

  /**
   * Get edit mode information for a ROI based on user role
   * @param {number} id - ROI ID
   * @param {boolean} isSuperAdmin - Whether user is super admin
   * @returns {Promise<Object|null>}
   */
  async getEditMode(id, isSuperAdmin) {
    const roi = await this.roiRepository.findById(id);
    if (!roi) return null;

    let editMode;
    let message;

    if (roi.isLegacy) {
      editMode = isSuperAdmin ? 'admin-legacy' : 'readonly';
      message = isSuperAdmin
        ? 'This is a legacy ROI. You can edit it as a super admin.'
        : 'This ROI is marked as legacy and cannot be edited.';
    } else if (isSuperAdmin) {
      editMode = 'admin';
      message = 'You can directly edit this ROI. Warning: This may break time series data.';
    } else {
      editMode = 'legacy-create';
      message = 'To modify this ROI, a new ROI will be created and this one will be marked as legacy.';
    }

    return {
      roiId: roi.id,
      roiName: roi.roiName,
      isLegacy: roi.isLegacy,
      timeseriesBroken: roi.timeseriesBroken,
      editMode,
      canDirectEdit: isSuperAdmin,
      requiresLegacyWorkflow: !isSuperAdmin && !roi.isLegacy,
      message
    };
  }

  /**
   * Count ROIs for an instrument
   * @param {number} instrumentId
   * @param {Object} [options]
   * @returns {Promise<number>}
   */
  async countByInstrument(instrumentId, options = {}) {
    return this.roiRepository.countByInstrument(instrumentId, options);
  }
}
