/**
 * ROI (Region of Interest) Domain Entity
 *
 * Represents a polygon region within an instrument image used for
 * vegetation analysis and time series extraction.
 *
 * @module domain/roi/ROI
 * @version 11.0.0
 */

export class ROI {
  static STATUSES = {
    ACTIVE: 'Active',
    INACTIVE: 'Inactive',
    ARCHIVED: 'Archived'
  };

  /**
   * Create a ROI entity
   * @param {Object} props - ROI properties
   */
  constructor({
    id = null,
    instrumentId,
    roiName,
    displayName = null,
    description = null,
    pointsJson = null,
    colorR = 255,
    colorG = 0,
    colorB = 0,
    alpha = 0.3,
    thickness = 7,
    autoGenerated = false,
    generatedDate = null,
    sourceImage = null,
    vegetationType = null,
    status = ROI.STATUSES.ACTIVE,
    isLegacy = false,
    legacyDate = null,
    replacedByROIId = null,
    timeseriesBroken = false,
    legacyReason = null,
    createdAt = null,
    updatedAt = null
  }) {
    this.id = id;
    this.instrumentId = instrumentId;
    this.roiName = roiName;
    this.displayName = displayName || roiName;
    this.description = description;
    this.pointsJson = pointsJson;
    this.colorR = colorR;
    this.colorG = colorG;
    this.colorB = colorB;
    this.alpha = alpha;
    this.thickness = thickness;
    this.autoGenerated = autoGenerated;
    this.generatedDate = generatedDate;
    this.sourceImage = sourceImage;
    this.vegetationType = vegetationType;
    this.status = status;
    this.isLegacy = isLegacy;
    this.legacyDate = legacyDate;
    this.replacedByROIId = replacedByROIId;
    this.timeseriesBroken = timeseriesBroken;
    this.legacyReason = legacyReason;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }

  /**
   * Validate the ROI entity
   * @returns {Object} { valid: boolean, errors: string[] }
   */
  validate() {
    const errors = [];

    if (!this.instrumentId) {
      errors.push('Instrument ID is required');
    }

    if (!this.roiName) {
      errors.push('ROI name is required');
    } else if (!/^ROI_\d{2}$/.test(this.roiName)) {
      errors.push('ROI name must follow pattern ROI_00, ROI_01, etc.');
    }

    // Validate points if present
    if (this.pointsJson) {
      try {
        const points = typeof this.pointsJson === 'string'
          ? JSON.parse(this.pointsJson)
          : this.pointsJson;

        if (!Array.isArray(points)) {
          errors.push('Points must be an array');
        } else if (points.length < 3) {
          errors.push('ROI must have at least 3 points to form a polygon');
        } else {
          // Validate each point
          for (let i = 0; i < points.length; i++) {
            const point = points[i];
            if (!Array.isArray(point) || point.length !== 2) {
              errors.push(`Point ${i} must be [x, y] coordinate pair`);
            } else if (typeof point[0] !== 'number' || typeof point[1] !== 'number') {
              errors.push(`Point ${i} coordinates must be numbers`);
            }
          }
        }
      } catch (e) {
        errors.push('Points JSON is invalid');
      }
    }

    // Validate color values
    if (this.colorR < 0 || this.colorR > 255) {
      errors.push('Color R must be between 0 and 255');
    }
    if (this.colorG < 0 || this.colorG > 255) {
      errors.push('Color G must be between 0 and 255');
    }
    if (this.colorB < 0 || this.colorB > 255) {
      errors.push('Color B must be between 0 and 255');
    }

    // Validate alpha
    if (this.alpha < 0 || this.alpha > 1) {
      errors.push('Alpha must be between 0 and 1');
    }

    // Validate status
    if (this.status && !Object.values(ROI.STATUSES).includes(this.status)) {
      errors.push(`Status must be one of: ${Object.values(ROI.STATUSES).join(', ')}`);
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  /**
   * Check if ROI is active
   * @returns {boolean}
   */
  isActive() {
    return this.status === ROI.STATUSES.ACTIVE && !this.isLegacy;
  }

  /**
   * Check if ROI can be edited
   * Non-legacy active ROIs can be edited
   * @returns {boolean}
   */
  canBeEdited() {
    return !this.isLegacy && this.status === ROI.STATUSES.ACTIVE;
  }

  /**
   * Mark ROI as legacy
   * @param {string} reason - Why the ROI is being marked as legacy
   * @param {number} [replacementId] - ID of the replacement ROI
   * @returns {ROI} This ROI with legacy status applied
   */
  markAsLegacy(reason, replacementId = null) {
    this.isLegacy = true;
    this.legacyDate = new Date().toISOString();
    this.legacyReason = reason;
    this.replacedByROIId = replacementId;
    this.status = ROI.STATUSES.ARCHIVED;
    return this;
  }

  /**
   * Mark that direct edit broke time series
   * @returns {ROI}
   */
  markTimeseriesBroken() {
    this.timeseriesBroken = true;
    return this;
  }

  /**
   * Get parsed points array
   * @returns {Array<[number, number]>}
   */
  getPoints() {
    if (!this.pointsJson) return [];
    try {
      return typeof this.pointsJson === 'string'
        ? JSON.parse(this.pointsJson)
        : this.pointsJson;
    } catch {
      return [];
    }
  }

  /**
   * Get number of vertices in polygon
   * @returns {number}
   */
  getPointCount() {
    return this.getPoints().length;
  }

  /**
   * Get color as hex string
   * @returns {string}
   */
  getColorHex() {
    const toHex = (n) => n.toString(16).padStart(2, '0');
    return `#${toHex(this.colorR)}${toHex(this.colorG)}${toHex(this.colorB)}`;
  }

  /**
   * Get color as RGB string
   * @returns {string}
   */
  getColorRGB() {
    return `rgb(${this.colorR}, ${this.colorG}, ${this.colorB})`;
  }

  /**
   * Get color as RGBA string
   * @returns {string}
   */
  getColorRGBA() {
    return `rgba(${this.colorR}, ${this.colorG}, ${this.colorB}, ${this.alpha})`;
  }

  /**
   * Convert to JSON for API responses
   * @returns {Object}
   */
  toJSON() {
    return {
      id: this.id,
      instrument_id: this.instrumentId,
      roi_name: this.roiName,
      display_name: this.displayName,
      description: this.description,
      points_json: this.pointsJson,
      color_r: this.colorR,
      color_g: this.colorG,
      color_b: this.colorB,
      alpha: this.alpha,
      thickness: this.thickness,
      auto_generated: this.autoGenerated,
      generated_date: this.generatedDate,
      source_image: this.sourceImage,
      vegetation_type: this.vegetationType,
      status: this.status,
      is_legacy: this.isLegacy,
      legacy_date: this.legacyDate,
      replaced_by_roi_id: this.replacedByROIId,
      timeseries_broken: this.timeseriesBroken,
      legacy_reason: this.legacyReason,
      created_at: this.createdAt,
      updated_at: this.updatedAt,
      // Computed fields
      point_count: this.getPointCount(),
      color_hex: this.getColorHex(),
      color_rgba: this.getColorRGBA()
    };
  }

  /**
   * Create ROI from database row
   * @param {Object} row - Database row
   * @returns {ROI}
   */
  static fromDatabase(row) {
    return new ROI({
      id: row.id,
      instrumentId: row.instrument_id,
      roiName: row.roi_name,
      displayName: row.display_name || row.roi_name,
      description: row.description,
      pointsJson: row.points_json,
      colorR: row.color_r ?? 255,
      colorG: row.color_g ?? 0,
      colorB: row.color_b ?? 0,
      alpha: row.alpha ?? 0.3,
      thickness: row.thickness ?? 7,
      autoGenerated: row.auto_generated ?? false,
      generatedDate: row.generated_date,
      sourceImage: row.source_image,
      vegetationType: row.vegetation_type,
      status: row.status || ROI.STATUSES.ACTIVE,
      isLegacy: row.is_legacy ?? false,
      legacyDate: row.legacy_date,
      replacedByROIId: row.replaced_by_roi_id,
      timeseriesBroken: row.timeseries_broken ?? false,
      legacyReason: row.legacy_reason,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    });
  }

  /**
   * Create ROI from API request data
   * @param {Object} data - API request data
   * @returns {ROI}
   */
  static fromRequest(data) {
    return new ROI({
      id: data.id,
      instrumentId: data.instrument_id,
      roiName: data.roi_name,
      displayName: data.display_name,
      description: data.description,
      pointsJson: data.points_json,
      colorR: data.color_r,
      colorG: data.color_g,
      colorB: data.color_b,
      alpha: data.alpha,
      thickness: data.thickness,
      autoGenerated: data.auto_generated,
      generatedDate: data.generated_date,
      sourceImage: data.source_image,
      vegetationType: data.vegetation_type,
      status: data.status,
      isLegacy: data.is_legacy,
      legacyDate: data.legacy_date,
      replacedByROIId: data.replaced_by_roi_id,
      timeseriesBroken: data.timeseries_broken,
      legacyReason: data.legacy_reason
    });
  }
}
